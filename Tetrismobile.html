<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>African Tetris — UG Artworks</title>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

<style>
  * {
    box-sizing: border-box;
    margin: 0;
    padding: 0;
    touch-action: manipulation;
    -webkit-user-select: none;
    user-select: none;
    -webkit-tap-highlight-color: transparent;
  }
  
  html, body {
    height: 100%;
    overflow: hidden;
    background: #2a2a2a;
  }
  
  body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 10px;
    background: linear-gradient(135deg, #5D4037, #3E2723);
  }

  .game-container {
    width: 100%;
    max-width: 400px;
    height: 90vh;
    max-height: 700px;
    background: #1a1a1a;
    border-radius: 20px;
    padding: 15px;
    box-shadow: 0 10px 30px rgba(0,0,0,0.5);
    border: 3px solid #444;
    display: flex;
    flex-direction: column;
    position: relative;
  }

  /* Header */
  .header {
    text-align: center;
    padding: 10px 0;
    margin-bottom: 10px;
    border-bottom: 2px solid #D2691E;
    color: #F4A460;
    font-weight: bold;
    font-size: 18px;
  }

  /* Main Game Layout */
  .main-game {
    flex: 1;
    display: flex;
    gap: 10px;
    min-height: 0;
  }

  /* Left Controls */
  .left-controls {
    width: 80px;
    display: flex;
    flex-direction: column;
    gap: 15px;
    justify-content: center;
    align-items: center;
  }

  /* Game Screen Area */
  .game-screen-area {
    flex: 1;
    background: #000;
    border-radius: 10px;
    padding: 8px;
    display: flex;
    flex-direction: column;
    border: 2px solid #444;
  }

  .game-display {
    flex: 1;
    background: #111;
    border-radius: 6px;
    position: relative;
    overflow: hidden;
    border: 1px solid #333;
  }

  #gameCanvas {
    width: 100%;
    height: 100%;
    display: block;
    image-rendering: pixelated;
  }

  /* Game Info */
  .game-info {
    display: grid;
    grid-template-columns: 1fr 1fr 1fr;
    gap: 8px;
    padding: 8px 0;
    background: rgba(0,0,0,0.4);
    border-radius: 6px;
    margin-top: 8px;
  }

  .info-item {
    text-align: center;
    font-size: 12px;
    font-weight: bold;
  }

  .info-label {
    color: #F4A460;
    margin-bottom: 2px;
    font-size: 11px;
  }

  .info-value {
    color: #fff;
    font-size: 14px;
  }

  /* Next Piece */
  .next-piece {
    position: absolute;
    top: 8px;
    right: 8px;
    background: rgba(0,0,0,0.8);
    padding: 5px;
    border-radius: 5px;
    border: 1px solid #D2691E;
    z-index: 5;
  }

  .next-label {
    color: #F4A460;
    font-size: 10px;
    text-align: center;
    margin-bottom: 3px;
  }

  #nextCanvas {
    width: 60px;
    height: 60px;
    display: block;
    image-rendering: pixelated;
  }

  /* Right Controls */
  .right-controls {
    width: 80px;
    display: flex;
    flex-direction: column;
    gap: 15px;
    justify-content: center;
    align-items: center;
  }

  /* Control Buttons */
  .control-btn {
    background: linear-gradient(145deg, #4a4a4a, #3a3a3a);
    border: none;
    border-radius: 50%;
    color: #fff;
    font-weight: bold;
    width: 70px;
    height: 70px;
    display: flex;
    align-items: center;
    justify-content: center;
    box-shadow: 0 4px 0 #2a2a2a, 0 4px 8px rgba(0,0,0,0.3);
    font-size: 24px;
    cursor: pointer;
    transition: all 0.1s;
    position: relative;
  }

  .control-btn:active {
    transform: translateY(3px);
    box-shadow: 0 1px 0 #2a2a2a, 0 1px 3px rgba(0,0,0,0.3);
  }

  .btn-green {
    background: linear-gradient(145deg, #228B22, #1a6b1a);
  }

  .btn-red {
    background: linear-gradient(145deg, #B22222, #8a1a1a);
  }

  .btn-yellow {
    background: linear-gradient(145deg, #F4A460, #c97c38);
    color: #000;
  }

  .btn-blue {
    background: linear-gradient(145deg, #1E90FF, #1a70cc);
  }

  /* Action Buttons */
  .action-buttons {
    display: flex;
    justify-content: space-between;
    padding: 10px 0;
    margin-top: 10px;
    gap: 10px;
  }

  .action-btn {
    background: linear-gradient(145deg, #4a4a4a, #3a3a3a);
    border: none;
    border-radius: 20px;
    color: #fff;
    font-weight: bold;
    padding: 12px 20px;
    font-size: 13px;
    cursor: pointer;
    box-shadow: 0 3px 0 #2a2a2a;
    flex: 1;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 5px;
    transition: all 0.1s;
  }

  .action-btn:active {
    transform: translateY(2px);
    box-shadow: 0 1px 0 #2a2a2a;
  }

  /* Screens */
  .screen {
    position: absolute;
    inset: 15px;
    background: rgba(0,0,0,0.95);
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    text-align: center;
    padding: 30px;
    z-index: 100;
    border-radius: 12px;
    border: 2px solid #444;
  }

  .screen h1 {
    color: #F4A460;
    margin-bottom: 20px;
    font-size: 28px;
    text-shadow: 0 2px 4px rgba(0,0,0,0.5);
  }

  .screen p {
    margin-bottom: 25px;
    color: #ccc;
    font-size: 14px;
    line-height: 1.4;
  }

  .screen-btns {
    display: flex;
    gap: 12px;
    flex-wrap: wrap;
    justify-content: center;
  }

  .screen-btn {
    background: linear-gradient(145deg, #D2691E, #8B4513);
    color: white;
    border: none;
    padding: 12px 24px;
    border-radius: 25px;
    font-weight: bold;
    cursor: pointer;
    box-shadow: 0 4px 0 #5D4037;
    min-width: 120px;
    transition: all 0.1s;
    font-size: 14px;
  }

  .screen-btn:active {
    transform: translateY(2px);
    box-shadow: 0 2px 0 #5D4037;
  }

  .hidden {
    display: none !important;
  }

  /* Game Over Stats */
  .game-stats {
    background: rgba(255,255,255,0.1);
    padding: 15px;
    border-radius: 10px;
    margin: 15px 0;
    min-width: 200px;
  }

  .stat-row {
    display: flex;
    justify-content: space-between;
    margin-bottom: 5px;
    font-size: 14px;
  }

  .stat-value {
    color: #F4A460;
    font-weight: bold;
  }

  /* Responsive */
  @media (max-height: 600px) {
    .game-container {
      height: 95vh;
      max-height: none;
    }
    
    .control-btn {
      width: 60px;
      height: 60px;
      font-size: 20px;
    }
    
    .left-controls, .right-controls {
      width: 70px;
    }
  }

  @media (max-width: 350px) {
    .control-btn {
      width: 55px;
      height: 55px;
      font-size: 18px;
    }
    
    .left-controls, .right-controls {
      width: 65px;
    }
    
    .action-btn {
      padding: 10px 15px;
      font-size: 12px;
    }
  }
</style>
</head>
<body>
  <div class="game-container">
    <div class="header">
      <i class="fas fa-mountain-sun"></i> AFRICAN TETRIS
    </div>

    <div class="main-game">
      <!-- Left Controls -->
      <div class="left-controls">
        <button class="control-btn" id="btnLeft" title="Move Left">
          <i class="fas fa-arrow-left"></i>
        </button>
        <button class="control-btn" id="btnDown" title="Soft Drop">
          <i class="fas fa-arrow-down"></i>
        </button>
        <button class="control-btn btn-red" id="btnPause" title="Pause/Resume">
          <i class="fas fa-pause"></i>
        </button>
      </div>

      <!-- Center Game Screen -->
      <div class="game-screen-area">
        <div class="game-display">
          <canvas id="gameCanvas"></canvas>
          
          <div class="next-piece">
            <div class="next-label">NEXT</div>
            <canvas id="nextCanvas"></canvas>
          </div>

          <!-- Menu Screen -->
          <div id="menuScreen" class="screen">
            <h1>TETRIS</h1>
            <p>Classic puzzle game with African-inspired design. Clear lines and score points!</p>
            <div class="screen-btns">
              <button class="screen-btn" id="startBtn">
                <i class="fas fa-play"></i> START GAME
              </button>
            </div>
            <div style="margin-top: 20px; font-size: 12px; color: #888">
              By James Mlelemba • UG Artworks
            </div>
          </div>

          <!-- Game Over Screen -->
          <div id="gameOverScreen" class="screen hidden">
            <h1>GAME OVER</h1>
            <div class="game-stats">
              <div class="stat-row">
                <span>Final Score:</span>
                <span class="stat-value" id="finalScore">0</span>
              </div>
              <div class="stat-row">
                <span>Level Reached:</span>
                <span class="stat-value" id="finalLevel">1</span>
              </div>
              <div class="stat-row">
                <span>Lines Cleared:</span>
                <span class="stat-value" id="finalLines">0</span>
              </div>
            </div>
            <div class="screen-btns">
              <button class="screen-btn" id="restartBtn">
                <i class="fas fa-redo"></i> PLAY AGAIN
              </button>
            </div>
          </div>

          <!-- Pause Screen -->
          <div id="pauseScreen" class="screen hidden">
            <h1>PAUSED</h1>
            <p>Game is paused</p>
            <div class="screen-btns">
              <button class="screen-btn" id="resumeBtn">
                <i class="fas fa-play"></i> RESUME
              </button>
              <button class="screen-btn" id="menuBtn">
                <i class="fas fa-home"></i> MAIN MENU
              </button>
            </div>
          </div>
        </div>

        <div class="game-info">
          <div class="info-item">
            <div class="info-label">SCORE</div>
            <div class="info-value" id="score">0</div>
          </div>
          <div class="info-item">
            <div class="info-label">LEVEL</div>
            <div class="info-value" id="level">1</div>
          </div>
          <div class="info-item">
            <div class="info-label">LINES</div>
            <div class="info-value" id="lines">0</div>
          </div>
        </div>
      </div>

      <!-- Right Controls -->
      <div class="right-controls">
        <button class="control-btn" id="btnRight" title="Move Right">
          <i class="fas fa-arrow-right"></i>
        </button>
        <button class="control-btn btn-yellow" id="btnRotate" title="Rotate">
          <i class="fas fa-undo"></i>
        </button>
        <button class="control-btn btn-green" id="btnDrop" title="Hard Drop">
          <i class="fas fa-arrow-down fa-rotate-90"></i>
        </button>
      </div>
    </div>

    <!-- Bottom Action Buttons -->
    <div class="action-buttons">
      <button class="action-btn" id="btnSound">
        <i class="fas fa-volume-up"></i> SOUND ON
      </button>
      <button class="action-btn btn-blue" id="btnRestart">
        <i class="fas fa-redo"></i> RESTART
      </button>
    </div>
  </div>

<script>
// ===== GAME CONSTANTS =====
const COLS = 10;
const ROWS = 20;
const COLORS = [
  '',          // 0: Empty
  '#FF5555',   // 1: Red - I piece
  '#5555FF',   // 2: Blue - J piece  
  '#FFAA00',   // 3: Orange - L piece
  '#FFFF55',   // 4: Yellow - O piece
  '#55FF55',   // 5: Green - S piece
  '#AA55FF',   // 6: Purple - T piece
  '#FF55FF'    // 7: Pink - Z piece
];

// Tetromino shapes [type][rotation][y][x]
const SHAPES = [
  // I
  [
    [[0,0,0,0], [1,1,1,1], [0,0,0,0], [0,0,0,0]],
    [[0,0,1,0], [0,0,1,0], [0,0,1,0], [0,0,1,0]]
  ],
  // J
  [
    [[1,0,0], [1,1,1], [0,0,0]],
    [[0,1,1], [0,1,0], [0,1,0]],
    [[0,0,0], [1,1,1], [0,0,1]],
    [[0,1,0], [0,1,0], [1,1,0]]
  ],
  // L
  [
    [[0,0,1], [1,1,1], [0,0,0]],
    [[0,1,0], [0,1,0], [0,1,1]],
    [[0,0,0], [1,1,1], [1,0,0]],
    [[1,1,0], [0,1,0], [0,1,0]]
  ],
  // O
  [
    [[1,1], [1,1]]
  ],
  // S
  [
    [[0,1,1], [1,1,0], [0,0,0]],
    [[0,1,0], [0,1,1], [0,0,1]]
  ],
  // T
  [
    [[0,1,0], [1,1,1], [0,0,0]],
    [[0,1,0], [0,1,1], [0,1,0]],
    [[0,0,0], [1,1,1], [0,1,0]],
    [[0,1,0], [1,1,0], [0,1,0]]
  ],
  // Z
  [
    [[1,1,0], [0,1,1], [0,0,0]],
    [[0,0,1], [0,1,1], [0,1,0]]
  ]
];

// ===== GAME STATE =====
let canvas, ctx, nextCanvas, nextCtx;
let board = [];
let currentPiece = null;
let nextPiece = null;
let score = 0, level = 1, linesCleared = 0;
let dropCounter = 0, dropInterval = 1000, lastTime = 0;
let gameRunning = false, gamePaused = false;
let soundEnabled = true;
let audioContext = null;

// ===== INITIALIZATION =====
function init() {
  console.log("Initializing African Tetris...");
  
  // Get canvas elements
  canvas = document.getElementById('gameCanvas');
  ctx = canvas.getContext('2d');
  nextCanvas = document.getElementById('nextCanvas');
  nextCtx = nextCanvas.getContext('2d');
  
  // Initialize game state
  resetGame();
  
  // Setup event listeners
  setupEventListeners();
  
  // Initial render
  resizeCanvases();
  draw();
  drawNextPiece();
  
  console.log("Game initialized successfully");
}

function resetGame() {
  board = createBoard();
  score = 0;
  level = 1;
  linesCleared = 0;
  dropInterval = 1000;
  gameRunning = false;
  gamePaused = false;
  
  updateUI();
}

function createBoard() {
  return Array.from({ length: ROWS }, () => Array(COLS).fill(0));
}

// ===== EVENT LISTENERS =====
function setupEventListeners() {
  // Game control buttons
  document.getElementById('startBtn').addEventListener('click', startGame);
  document.getElementById('restartBtn').addEventListener('click', startGame);
  document.getElementById('btnRestart').addEventListener('click', startGame);
  document.getElementById('resumeBtn').addEventListener('click', resumeGame);
  document.getElementById('menuBtn').addEventListener('click', showMenu);
  
  // Sound toggle
  document.getElementById('btnSound').addEventListener('click', toggleSound);
  
  // Game control buttons
  const setupControl = (id, action) => {
    const btn = document.getElementById(id);
    btn.addEventListener('touchstart', (e) => {
      e.preventDefault();
      if (gameRunning && !gamePaused) action();
    });
    btn.addEventListener('mousedown', () => {
      if (gameRunning && !gamePaused) action();
    });
  };
  
  setupControl('btnLeft', () => { movePiece(-1); });
  setupControl('btnRight', () => { movePiece(1); });
  setupControl('btnDown', softDrop);
  setupControl('btnRotate', rotatePiece);
  setupControl('btnDrop', hardDrop);
  setupControl('btnPause', togglePause);
  
  // Keyboard controls
  document.addEventListener('keydown', handleKeyPress);
  
  // Window resize
  window.addEventListener('resize', resizeCanvases);
}

function handleKeyPress(e) {
  if (!gameRunning || gamePaused) return;
  
  switch(e.key) {
    case 'ArrowLeft': movePiece(-1); break;
    case 'ArrowRight': movePiece(1); break;
    case 'ArrowDown': softDrop(); break;
    case 'ArrowUp': rotatePiece(); break;
    case ' ': hardDrop(); break;
    case 'p': case 'P': togglePause(); break;
  }
  
  // Prevent arrow keys from scrolling the page
  if (['ArrowLeft', 'ArrowRight', 'ArrowDown', 'ArrowUp', ' '].includes(e.key)) {
    e.preventDefault();
  }
}

// ===== GAME LOGIC =====
function startGame() {
  console.log("Starting new game");
  
  resetGame();
  gameRunning = true;
  gamePaused = false;
  
  // Hide screens
  document.getElementById('menuScreen').classList.add('hidden');
  document.getElementById('gameOverScreen').classList.add('hidden');
  document.getElementById('pauseScreen').classList.add('hidden');
  
  // Generate first pieces
  nextPiece = createRandomPiece();
  spawnPiece();
  
  // Update UI
  updateUI();
  updatePauseButton();
  
  // Start game loop
  lastTime = performance.now();
  requestAnimationFrame(gameLoop);
  
  playSound('start');
}

function resumeGame() {
  gamePaused = false;
  document.getElementById('pauseScreen').classList.add('hidden');
  updatePauseButton();
  lastTime = performance.now();
  requestAnimationFrame(gameLoop);
}

function showMenu() {
  gameRunning = false;
  gamePaused = false;
  document.getElementById('pauseScreen').classList.add('hidden');
  document.getElementById('menuScreen').classList.remove('hidden');
  updatePauseButton();
}

function togglePause() {
  if (!gameRunning) return;
  
  gamePaused = !gamePaused;
  
  if (gamePaused) {
    document.getElementById('pauseScreen').classList.remove('hidden');
  } else {
    document.getElementById('pauseScreen').classList.add('hidden');
    lastTime = performance.now();
    requestAnimationFrame(gameLoop);
  }
  
  updatePauseButton();
}

function updatePauseButton() {
  const icon = document.querySelector('#btnPause i');
  icon.className = gamePaused ? 'fas fa-play' : 'fas fa-pause';
}

function toggleSound() {
  soundEnabled = !soundEnabled;
  const btn = document.getElementById('btnSound');
  const icon = btn.querySelector('i');
  const text = btn.querySelector('span');
  
  if (soundEnabled) {
    icon.className = 'fas fa-volume-up';
    text.textContent = 'SOUND ON';
  } else {
    icon.className = 'fas fa-volume-mute';
    text.textContent = 'SOUND OFF';
  }
}

// ===== PIECE MANAGEMENT =====
function createRandomPiece() {
  const type = Math.floor(Math.random() * SHAPES.length);
  const rotation = 0;
  const matrix = JSON.parse(JSON.stringify(SHAPES[type][rotation]));
  
  return {
    type,
    rotation,
    matrix,
    color: type + 1,
    x: Math.floor(COLS / 2) - Math.floor(matrix[0].length / 2),
    y: 0
  };
}

function spawnPiece() {
  currentPiece = nextPiece || createRandomPiece();
  nextPiece = createRandomPiece();
  
  // Center the piece
  currentPiece.x = Math.floor(COLS / 2) - Math.floor(currentPiece.matrix[0].length / 2);
  currentPiece.y = 0;
  
  // Check for game over
  if (checkCollision(currentPiece)) {
    endGame();
    return;
  }
  
  drawNextPiece();
}

function rotatePiece() {
  if (!currentPiece) return;
  
  const originalRotation = currentPiece.rotation;
  const originalMatrix = JSON.parse(JSON.stringify(currentPiece.matrix));
  
  // Calculate new rotation
  currentPiece.rotation = (currentPiece.rotation + 1) % SHAPES[currentPiece.type].length;
  currentPiece.matrix = JSON.parse(JSON.stringify(SHAPES[currentPiece.type][currentPiece.rotation]));
  
  // Wall kick - try moving left/right if rotation causes collision
  if (checkCollision(currentPiece)) {
    const kicks = [-1, 1, -2, 2];
    for (const kick of kicks) {
      currentPiece.x += kick;
      if (!checkCollision(currentPiece)) {
        playSound('rotate');
        return;
      }
      currentPiece.x -= kick;
    }
    
    // Revert if no kick works
    currentPiece.rotation = originalRotation;
    currentPiece.matrix = originalMatrix;
  } else {
    playSound('rotate');
  }
}

function movePiece(dx) {
  if (!currentPiece) return;
  
  currentPiece.x += dx;
  
  if (checkCollision(currentPiece)) {
    currentPiece.x -= dx;
  } else {
    playSound('move');
  }
}

function softDrop() {
  if (!currentPiece) return;
  
  currentPiece.y++;
  
  if (checkCollision(currentPiece)) {
    currentPiece.y--;
  } else {
    score++;
    updateUI();
    playSound('move');
  }
}

function hardDrop() {
  if (!currentPiece) return;
  
  let dropDistance = 0;
  while (!checkCollision(currentPiece)) {
    currentPiece.y++;
    dropDistance++;
  }
  
  currentPiece.y--;
  score += dropDistance * 2;
  
  lockPiece();
  clearLines();
  spawnPiece();
  
  playSound('drop');
}

function checkCollision(piece) {
  for (let y = 0; y < piece.matrix.length; y++) {
    for (let x = 0; x < piece.matrix[y].length; x++) {
      if (piece.matrix[y][x]) {
        const boardX = piece.x + x;
        const boardY = piece.y + y;
        
        if (boardX < 0 || boardX >= COLS || boardY >= ROWS) {
          return true;
        }
        
        if (boardY >= 0 && board[boardY][boardX]) {
          return true;
        }
      }
    }
  }
  
  return false;
}

function lockPiece() {
  for (let y = 0; y < currentPiece.matrix.length; y++) {
    for (let x = 0; x < currentPiece.matrix[y].length; x++) {
      if (currentPiece.matrix[y][x]) {
        const boardY = currentPiece.y + y;
        if (boardY >= 0) {
          board[boardY][currentPiece.x + x] = currentPiece.color;
        }
      }
    }
  }
}

function clearLines() {
  let linesRemoved = 0;
  
  for (let y = ROWS - 1; y >= 0; y--) {
    if (board[y].every(cell => cell !== 0)) {
      // Remove the line
      board.splice(y, 1);
      // Add new empty line at top
      board.unshift(Array(COLS).fill(0));
      linesRemoved++;
      y++; // Recheck this position
    }
  }
  
  if (linesRemoved > 0) {
    // Update score based on lines cleared
    const linePoints = [0, 40, 100, 300, 1200];
    score += linePoints[linesRemoved] * level;
    linesCleared += linesRemoved;
    
    // Update level
    level = Math.floor(linesCleared / 10) + 1;
    dropInterval = Math.max(100, 1000 - (level - 1) * 80);
    
    updateUI();
    playSound('clear');
  }
}

function endGame() {
  gameRunning = false;
  
  // Update final stats
  document.getElementById('finalScore').textContent = score;
  document.getElementById('finalLevel').textContent = level;
  document.getElementById('finalLines').textContent = linesCleared;
  
  // Show game over screen
  document.getElementById('gameOverScreen').classList.remove('hidden');
  
  playSound('gameover');
}

// ===== GAME LOOP =====
function gameLoop(currentTime) {
  if (!gameRunning || gamePaused) return;
  
  const deltaTime = currentTime - lastTime;
  lastTime = currentTime;
  
  dropCounter += deltaTime;
  if (dropCounter > dropInterval) {
    currentPiece.y++;
    
    if (checkCollision(currentPiece)) {
      currentPiece.y--;
      lockPiece();
      clearLines();
      spawnPiece();
    }
    
    dropCounter = 0;
  }
  
  draw();
  requestAnimationFrame(gameLoop);
}

// ===== RENDERING =====
function resizeCanvases() {
  const gameDisplay = document.querySelector('.game-display');
  const displayWidth = gameDisplay.clientWidth;
  const displayHeight = gameDisplay.clientHeight;
  
  // Calculate block size to fit the board
  const blockSize = Math.min(
    Math.floor(displayWidth / COLS),
    Math.floor(displayHeight / ROWS)
  );
  
  // Set main canvas size
  canvas.width = COLS * blockSize;
  canvas.height = ROWS * blockSize;
  canvas.style.width = canvas.width + 'px';
  canvas.style.height = canvas.height + 'px';
  
  // Set next piece canvas size
  nextCanvas.width = 60;
  nextCanvas.height = 60;
}

function draw() {
  const blockSize = canvas.width / COLS;
  
  // Clear canvas
  ctx.fillStyle = '#000';
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  
  // Draw board
  for (let y = 0; y < ROWS; y++) {
    for (let x = 0; x < COLS; x++) {
      if (board[y][x]) {
        drawBlock(x, y, board[y][x], blockSize);
      }
    }
  }
  
  // Draw current piece
  if (currentPiece) {
    for (let y = 0; y < currentPiece.matrix.length; y++) {
      for (let x = 0; x < currentPiece.matrix[y].length; x++) {
        if (currentPiece.matrix[y][x]) {
          drawBlock(
            currentPiece.x + x,
            currentPiece.y + y,
            currentPiece.color,
            blockSize
          );
        }
      }
    }
  }
  
  // Draw grid
  ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
  ctx.lineWidth = 1;
  
  for (let x = 0; x <= COLS; x++) {
    ctx.beginPath();
    ctx.moveTo(x * blockSize, 0);
    ctx.lineTo(x * blockSize, canvas.height);
    ctx.stroke();
  }
  
  for (let y = 0; y <= ROWS; y++) {
    ctx.beginPath();
    ctx.moveTo(0, y * blockSize);
    ctx.lineTo(canvas.width, y * blockSize);
    ctx.stroke();
  }
}

function drawBlock(x, y, colorId, blockSize) {
  const color = COLORS[colorId];
  
  // Draw block
  ctx.fillStyle = color;
  ctx.fillRect(x * blockSize, y * blockSize, blockSize, blockSize);
  
  // Draw highlight
  ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
  ctx.fillRect(x * blockSize, y * blockSize, blockSize, 2);
  ctx.fillRect(x * blockSize, y * blockSize, 2, blockSize);
  
  // Draw shadow
  ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
  ctx.fillRect(x * blockSize + blockSize - 2, y * blockSize, 2, blockSize);
  ctx.fillRect(x * blockSize, y * blockSize + blockSize - 2, blockSize, 2);
}

function drawNextPiece() {
  if (!nextPiece) return;
  
  nextCtx.clearRect(0, 0, nextCanvas.width, nextCanvas.height);
  
  const blockSize = 10;
  const pieceWidth = nextPiece.matrix[0].length;
  const pieceHeight = nextPiece.matrix.length;
  
  const offsetX = (nextCanvas.width - pieceWidth * blockSize) / 2;
  const offsetY = (nextCanvas.height - pieceHeight * blockSize) / 2;
  
  for (let y = 0; y < nextPiece.matrix.length; y++) {
    for (let x = 0; x < nextPiece.matrix[y].length; x++) {
      if (nextPiece.matrix[y][x]) {
        nextCtx.fillStyle = COLORS[nextPiece.color];
        nextCtx.fillRect(
          offsetX + x * blockSize,
          offsetY + y * blockSize,
          blockSize,
          blockSize
        );
        
        // Draw block border
        nextCtx.strokeStyle = 'rgba(0, 0, 0, 0.5)';
        nextCtx.lineWidth = 1;
        nextCtx.strokeRect(
          offsetX + x * blockSize,
          offsetY + y * blockSize,
          blockSize,
          blockSize
        );
      }
    }
  }
}

function updateUI() {
  document.getElementById('score').textContent = score;
  document.getElementById('level').textContent = level;
  document.getElementById('lines').textContent = linesCleared;
}

// ===== SOUND SYSTEM =====
function playSound(type) {
  if (!soundEnabled) return;
  
  try {
    if (!audioContext) {
      audioContext = new (window.AudioContext || window.webkitAudioContext)();
    }
    
    const oscillator = audioContext.createOscillator();
    const gainNode = audioContext.createGain();
    
    oscillator.connect(gainNode);
    gainNode.connect(audioContext.destination);
    
    // Set sound parameters based on type
    switch(type) {
      case 'move':
        oscillator.frequency.value = 150;
        gainNode.gain.value = 0.1;
        break;
      case 'rotate':
        oscillator.frequency.value = 200;
        gainNode.gain.value = 0.1;
        break;
      case 'drop':
        oscillator.frequency.value = 100;
        gainNode.gain.value = 0.2;
        break;
      case 'clear':
        oscillator.frequency.value = 300;
        gainNode.gain.value = 0.3;
        break;
      case 'gameover':
        oscillator.frequency.value = 80;
        gainNode.gain.value = 0.4;
        break;
      case 'start':
        oscillator.frequency.value = 250;
        gainNode.gain.value = 0.2;
        break;
    }
    
    oscillator.type = 'square';
    
    // Play the sound
    oscillator.start();
    oscillator.stop(audioContext.currentTime + 0.1);
    
  } catch (error) {
    console.warn('Audio not supported:', error);
    soundEnabled = false;
    toggleSound(); // Update UI to reflect disabled sound
  }
}

// ===== INITIALIZE GAME =====
document.addEventListener('DOMContentLoaded', init);
</script>
</body>
</html>